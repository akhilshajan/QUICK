! Routines related to the calculation of anharmonic (VPT2)
! vibrational partition functions

module dlf_vpt2_part_func
use dlf_parameter_module
!use dlf_global, only: glob, stdout
implicit none

public  ::  qvib_harmonic, qvib_anharmonic
private ::  freqsav,Xsav,Tsav,qva_rec, &
          & qnmax_param,Qaddtol

logical, parameter  :: force_harmonic_approximation=.false.
logical, save :: force_harmonic_approximation_warning_dropped=.false.
real(rk), parameter :: Qaddtol=1.e-100_rk
!real(rk), parameter :: Qaddtol=0._rk
integer, parameter :: qnmax_param=1000000
real(rk), allocatable, dimension(:), save :: freqsav, vpt2fundasav
real(rk), allocatable, dimension(:,:), save :: Xsav
logical, allocatable, dimension(:), save :: spt_mask_sav
real(rk), save :: Tsav, kb_cm_inv, Emaxsav, del_ener_sav, Eswitchsav
integer, save :: Nsav
character(len=200), save :: qnform

contains

!***************************************************
!***************************************************

! Make an input file bdens.dat to be used with bdens of the 
! MultiWell package. See documentation for more info about this interface

subroutine generate_bdens_input(Neff,freqs,Xmat,Arot,Brot,Crot,Tmin,Tmax)
  implicit none
  integer, intent(in) :: Neff
  real(rk), dimension(Neff), intent(in) :: freqs
  real(rk), dimension(Neff,Neff), intent(in) :: Xmat
  real(rk), intent(in) :: Arot,Brot,Crot,Tmin,Tmax
  
  real(rk), parameter :: zerthresh = 1.e-10_rk, symthresh=1.e-2_rk
  real(rk), parameter :: Egrain1_max=20._rk, Egrain1_min=5._rk, Emax1_mini=3500._rk
  integer :: i,j,nsep,rotdim, rotdim_sec
  character(len=1000) :: myfmt
  real(rk) :: Egrain1,Egrain2,Emax2,Emax1
  real(rk) :: Beff, Beff_sec
  integer :: imax1,imax2,Isize
  
  Egrain1=0.5_rk*6.950e-2_rk*Tmin   ! Multiwell recommendation: '~10% of kBT, or less,  Typical choices: 5 or 10 cm-1'
  Egrain1=min(Egrain1,Egrain1_max)
  Egrain1=max(Egrain1,Egrain1_min)
  Egrain1=real(nint(Egrain1))
  Emax1=maxval(freqs,dim=1)*1.5_rk  ! Multiwell recommendation: '[...]  so that Emax1 is greater than the highest vibrational wavenumber (typically greater than ~3000 cm-1).'
  Emax1=max(Emax1,Emax1_mini)
  imax1=ceiling(Emax1/Egrain1)+1
  Emax1=(Imax1-1)*Egrain1
    
  Egrain2=0.25_rk*6.950e-1_rk*Tmin  ! Multiwell recommendation: '[...]  so that Egrain2 ≤ kBT/2'
  Egrain2=real(nint(Egrain2))
  Emax2=E_max_fit(Neff,Tmax)
  imax2=ceiling(Emax2/Egrain2)+1
  Emax2=(imax2-1)*Egrain2
  
  Isize=imax1+imax2
  
  if ( abs(Arot) <= zerthresh ) then  ! linear molecule
    nsep=1
    rotdim=1
    Beff=sqrt(Brot*Crot)
  elseif ( abs( Arot - Brot) <= symthresh .and. abs( Crot - Brot) <= symthresh ) then ! nearly spherical top
    nsep=1
    rotdim=3
    Beff=(Arot*Brot*Crot)**(1._rk/3._rk)
  else  ! Anything else, treated as a (quasi-)symmetric top, in the separable approximation
    nsep=2
    rotdim=2
    rotdim_sec=1
    if ( abs( Arot - Brot) < abs( Crot - Brot) ) then
      Beff=sqrt(Arot*Brot)
      Beff_sec=Crot
    else
      Beff=sqrt(Brot*Crot)
      Beff_sec=Arot
    endif
  endif
  
  open(unit=8090,file='bdens.dat', status='replace',action='write')
  write(8090,'(A)') 'dummy_name'
  write(8090,'(A)') 'Input for bdens (part of MultiWell by Barker et al., '// &
                &   'http://clasp-research.engin.umich.edu/multiwell/) for '// &
                &   'anharmonic DOS/partition function'
  write(8090,'(A)') 'File generated by the VPT2 module of DL-FIND (part of '// &
                    'ChemShell, http://www.theochem.uni-stuttgart.de/kaestner/dlfind.html)'
  write(8090,'(3(I0,1X),A)') neff, 0, 0, 'We'
  
  do i=1,Neff
    write(8090,'(ES24.16)') freqs(i)
  enddo
  
  write(8090,'(A)') 'lower'
  
  do i=1,Neff
    write(myfmt,'(A,I0,A)') '(',i,'(ES24.16,1X))'
    write(8090,fmt=trim(adjustl(myfmt))) (Xmat(i,j),j=1,i)
  enddo
  
  write(8090,'(I0,1X,A)') nsep, 'CM-1'
  write(8090,'(I0,1X,A,1X,ES13.5,1X,F5.1,1X,I0)') Neff+1, 'qro', Beff, 1._rk, rotdim
  if (nsep > 1) then
    write(8090,'(I0,1X,A,1X,ES13.5,1X,F5.1,1X,I0)') Neff+2, 'qro', Beff_sec, 1._rk, rotdim_sec
  endif

  write(8090,'(ES24.16,1X,2(I0,1X),ES24.16,1X,2(A,1X),F5.1)') Egrain1, imax1, Isize, &
                                              & Emax2, 'Better', 'AUTO', 0._rk
  write(8090,'(A)') 'nochekstart'
  
  close(8090)
  
  return
end subroutine generate_bdens_input

!***************************************************
!***************************************************

! Make an input file sctst.dat to be used with sctst of the 
! MultiWell package. See documentation for more info about this interface

subroutine generate_sctst_input(Nreal,realfreqs,Xmat,Arot,Brot,Crot,Tmin,Tmax,vimag, Xff, Xkf)
  implicit none
  integer, intent(in) :: Nreal
  real(rk), dimension(nreal), intent(in) :: realfreqs
  real(rk), dimension(nreal,nreal), intent(in) :: Xmat
  real(rk), intent(in) :: Arot,Brot,Crot,Tmin,Tmax
  real(rk), intent(in) :: vimag, Xff
  real(rk), dimension(nreal), intent(in) :: Xkf
  
  real(rk), parameter :: zerthresh = 1.e-10_rk, symthresh=1.e-2_rk
  real(rk), parameter :: Egrain1_max=20._rk, Egrain1_min=5._rk, Emax1_mini=3500._rk
  integer :: i,j,nsep,rotdim, rotdim_sec
  character(len=1000) :: myfmt
  real(rk) :: Egrain1,Egrain2,Emax2,Emax1
  real(rk) :: Beff, Beff_sec
  integer :: imax1,imax2,Isize
  
  Egrain1=0.5_rk*6.950e-2_rk*Tmin   ! Multiwell recommendation: '~10% of kBT, or less,  Typical choices: 5 or 10 cm-1'
  Egrain1=min(Egrain1,Egrain1_max)
  Egrain1=max(Egrain1,Egrain1_min)
  Egrain1=real(nint(Egrain1))
  Emax1=maxval(realfreqs,dim=1)*1.5_rk  ! Multiwell recommendation: '[...]  so that Emax1 is greater than the highest vibrational wavenumber (typically greater than ~3000 cm-1).'
  Emax1=max(Emax1,Emax1_mini)
  imax1=ceiling(Emax1/Egrain1)+1
  Emax1=(Imax1-1)*Egrain1
    
  Egrain2=0.25_rk*6.950e-1_rk*Tmin  ! Multiwell recommendation: '[...]  so that Egrain2 ≤ kBT/2'
  Egrain2=real(nint(Egrain2))
  Emax2=E_max_fit(Nreal,Tmax)
  imax2=ceiling(Emax2/Egrain2)+1
  Emax2=(imax2-1)*Egrain2
  
  Isize=imax1+imax2

  if ( abs(Arot) <= zerthresh ) then  ! linear molecule
    nsep=1
    rotdim=1
    Beff=sqrt(Brot*Crot)
  elseif ( abs( Arot - Brot) <= symthresh .and. abs( Crot - Brot) <= symthresh ) then ! nearly spherical top
    nsep=1
    rotdim=3
    Beff=(Arot*Brot*Crot)**(1._rk/3._rk)
  else  ! Anything else, treated as a (quasi-)symmetric top, in the separable approximation
    nsep=2
    rotdim=2
    rotdim_sec=1
    if ( abs( Arot - Brot) < abs( Crot - Brot) ) then
      Beff=sqrt(Arot*Brot)
      Beff_sec=Crot
    else
      Beff=sqrt(Brot*Crot)
      Beff_sec=Arot
    endif
  endif
  
  open(unit=8090,file='sctst.dat', status='replace',action='write')
  write(8090,'(A)') 'dummy_name'
  write(8090,'(A)') '!!! Remember to set barriers correctly. Right now, dummy value '// &
                  & '6666cm-1 is used !!! Input for sctst (part of MultiWell by Barker '// &
                  & 'et al., http://clasp-research.engin.umich.edu/multiwell/) for '// &
                  & 'semi-classical TST'
  write(8090,'(A)') 'File generated by the VPT2 module of DL-FIND (part of ChemShell, '// &
                  & 'http://www.theochem.uni-stuttgart.de/kaestner/dlfind.html)'
  write(8090,'(3(I0,1X),A)') nreal, 0, 0, 'We'
  
  do i=1,Nreal
    write(8090,'(ES24.16)') realfreqs(i)
  enddo
  
  write(8090,'(A)') 'lower'
  
  do i=1,Nreal
    write(myfmt,'(A,I0,A)') '(',i,'(ES24.16,1X))'
    write(8090,fmt=trim(adjustl(myfmt))) (Xmat(i,j),j=1,i)
  enddo
  
  write(8090,'(I0,1X,A)') nsep, 'CM-1'
  write(8090,'(I0,1X,A,1X,ES13.5,1X,F5.1,1X,I0)') Nreal+1, 'qro', Beff, 1._rk, rotdim
  if (nsep > 1) then
    write(8090,'(I0,1X,A,1X,ES13.5,1X,F5.1,1X,I0)') Nreal+2, 'qro', Beff_sec, 1._rk, rotdim_sec
  endif
  write(8090,'(ES24.16,1X,2(I0,1X),ES24.16,1X,A)') Egrain1, imax1, Isize, Emax2, 'Better'
  write(8090,'(A)') 'nochekstart'
  write(8090,'(A)') 'Better'
  write(8090,'(A)') 'VPT4A'
  write(8090,'(F7.1,1X,F8.1,1X,A)') 6666._rk, 16666._rk, 'cm'
  write(8090,'(2(ES24.16,1X))') vimag, Xff
  do i=1,Nreal
    write(8090,'(ES24.16)') XkF(i)
  enddo
  close(8090)
  
  return
end subroutine generate_sctst_input

!***************************************************
!***************************************************

! Harmonic vibrational partition function, 
! using the analytic formula

function qvib_harmonic(Neff,freq,Temp,saddle_point)
  use dlf_constants
  implicit none
  integer, intent(in) :: Neff
  real(rk), dimension(Neff), intent(in) :: freq
  real(rk), intent(in) :: Temp
  real(rk) :: qvib_harmonic
  logical, intent(in), optional :: saddle_point
  integer :: nreal
  
  call dlf_constants_get("KBOLTZ_CM_INV",kb_cm_inv)
  
  if (present(saddle_point)) then
    if (saddle_point) then
      nreal=neff-1
    else
      nreal=neff
    endif
  else
    nreal=neff
  endif
  if (nreal.gt.0) then
    qvib_harmonic = product(1._rk-exp(-freq(1:nreal)/(kb_cm_inv*Temp)))
    qvib_harmonic = 1._rk/qvib_harmonic
  else 
    qvib_harmonic=1._rk
  endif
  return
end function qvib_harmonic

!***************************************************
!***************************************************

! Driver for anharmonic partition function, using 
! the canonical recursive counting formula. 
! Frequencies, X matrix, temperature etc. are saved 
! in module-wide persistent variables, to reduce amount 
! of dummy arguments to be passed.

function qvib_anharmonic(Neff,freq,X,Temp,hybrid,saddle_point)
  use dlf_global, only: stdout
  use dlf_allocate
  use dlf_constants
  use dlf_vpt2_terms, only: vpt2_fundamentals
  implicit none
  integer, intent(in) :: Neff
  real(rk), dimension(Neff), intent(in) :: freq
  real(rk), dimension(Neff,Neff), intent(in) :: X
  real(rk), intent(in) :: Temp
  logical, intent(in) :: hybrid
  logical, intent(in), optional :: saddle_point
  real(rk) :: qvib_anharmonic
  
  real(rk), dimension(Neff) :: fundatmp
  integer, allocatable, dimension(:) :: idumarr
  integer :: nreal

  if (present(saddle_point)) then
    if (saddle_point) then
      nreal=neff-1
    else
      nreal=neff
    endif
  else
    nreal=neff
  endif
  
  qvib_anharmonic=0._rk
  Nsav=nreal
  Tsav=Temp
  
  qnform=''
  write(qnform,'(A,I0,A)') '(',nreal,'(I0,1X))'
  
  if (allocated(freqsav)) call deallocate(freqsav)
  if (allocated(Xsav)) call deallocate(Xsav)
  call allocate(freqsav,nreal)
  call allocate(Xsav,nreal,nreal)

  freqsav(1:nreal)=freq(1:nreal)
  Xsav(1:nreal,1:nreal)=X(1:nreal,1:nreal)
  
  if (force_harmonic_approximation) then
    Xsav(1:nreal,1:nreal)=0._rk
    if (.not. force_harmonic_approximation_warning_dropped) then
      force_harmonic_approximation_warning_dropped=.true.
      write(stdout,'(A)') ''
      write(stdout,'(A)') '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'
      write(stdout,'(A)') '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'
      write(stdout,'(A)') ''
      write(stdout,'(A)') '             <<<<   WARNING!! >>>>           '
      write(stdout,'(A)') ''
      write(stdout,'(A)') ' Parameter "force_harmonic_approximation"'
      write(stdout,'(A)') ' is set to .true., meaning the anharmonic'
      write(stdout,'(A)') ' constants are ignored for the state counting'
      write(stdout,'(A)') ' routines.'
      write(stdout,'(A)') ''
      write(stdout,'(A)') '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'
      write(stdout,'(A)') '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'
      write(stdout,'(A)') ''
    endif
  endif
  
  if (hybrid) then
    if (allocated(vpt2fundasav)) call deallocate(vpt2fundasav)
    if (allocated(spt_mask_sav)) call deallocate(spt_mask_sav)
    call allocate(vpt2fundasav,nreal)
    call allocate(spt_mask_sav,nreal)
    spt_mask_sav(:)=.false.
    !call vpt2_fundamentals(nreal,freqsav,Xsav,vpt2fundasav,.false.)
    call vpt2_fundamentals(Neff,freq,X,fundatmp,saddle_point)
    vpt2fundasav(1:nreal)=fundatmp(1:nreal)
  endif
  
  call dlf_constants_get("KBOLTZ_CM_INV",kb_cm_inv)
  
  allocate(idumarr(0))
  call qva_rec(nreal,qvib_anharmonic,idumarr,hybrid)
  
  if (hybrid) then
    call deallocate(vpt2fundasav)
    call deallocate(spt_mask_sav)
  endif
  
  call deallocate(idumarr)
  call deallocate(Xsav)
  call deallocate(freqsav)

  return
end function qvib_anharmonic

!***************************************************
!***************************************************

! Recursive brute-force counting algorithm, for obtaining
! anharmonic partition function 

recursive subroutine qva_rec(Nsub,Q,qn_inact,hybrid)
  use dlf_vpt2_terms, only: E_vpt2, E_vpt2_hybrid
  implicit none
  integer, intent(in) :: Nsub
  real(rk), intent(inout)  :: Q
  integer, dimension(1:Nsav-Nsub), intent(in) :: qn_inact
  logical, intent(in) :: hybrid
  
  integer :: v
  real(rk) :: Qold,Eold,En
  integer, allocatable, dimension(:) :: izero

  if (hybrid) then
    spt_mask_sav(1:Nsub)=.false.
  endif
  
  if (Nsub == 1) then
    En=-1._rk
    do v=0,qnmax_param
      Qold=Q
      Eold=En
      if (hybrid) then
        En=E_vpt2_hybrid(Nsav,freqsav,vpt2fundasav,spt_mask_sav,[v,qn_inact],Xsav)
      else
        En=E_vpt2(Nsav,freqsav,[v,qn_inact],Xsav)
      endif
      if (En<Eold) then
        !write(stdout,*) '*** VPT2 breakdown. Energy decreases with increasing quantum number ***'
        !write(stdout,*) 'Eold, E: ', Eold, En
        if (hybrid) then
          spt_mask_sav(Nsub)=.true.
          En=E_vpt2_hybrid(Nsav,freqsav,vpt2fundasav,spt_mask_sav,[v,qn_inact],Xsav)
        else
          if(En<0._rk) exit
        endif
        !exit
      endif
      Q=Q+exp(-En/(kb_cm_inv*Tsav))
      if (Qold>=1._rk .and. abs((Qold-Q)/Qold) < Qaddtol) exit
    enddo
  else
    En=-1._rk
    do v=0,qnmax_param
      Qold=Q
      Eold=En
      allocate(izero(Nsub-1))
      izero(:)=0
      if (hybrid) then
        En=E_vpt2_hybrid(Nsav,freqsav,vpt2fundasav,spt_mask_sav,[izero,v,qn_inact],Xsav)
      else
        En=E_vpt2(Nsav,freqsav,[izero,v,qn_inact],Xsav)
      endif
      deallocate(izero)
      if (En<Eold) then
        !write(stdout,*) '*** VPT2 breakdown. Energy decreases with increasing quantum number ***'
        !write(stdout,*) 'Eold, E: ', Eold, En
        if (hybrid) then
          spt_mask_sav(Nsub)=.true.
          En=E_vpt2_hybrid(Nsav,freqsav,vpt2fundasav,spt_mask_sav,[v,qn_inact],Xsav)
        else
          if(En<0._rk) exit
        endif
        !exit
      endif
      call qva_rec(Nsub-1,Q,[v,qn_inact],hybrid)
      if (Qold>=1._rk .and. abs((Qold-Q)/Qold) < Qaddtol) exit
    enddo
  endif
  return
end subroutine qva_rec

!***************************************************
!***************************************************

! Driver for anharmonic partition function, using 
! the micro-canonical recursive counting formula.
! This proceeds via the density of states rho(E),
! a microcanonical quantity, 
! which means that several temperatures can then 
! be handled at once, via Laplace transform of the DOS
! giving the canonical partition function q(T) 
! Frequencies, X matrix, temperature etc. are saved 
! in module-wide persistent variables, to reduce amount 
! of dummy arguments to be passed.

function qvib_anharmonic_via_rho(Neff,freq,X,nT,Temps,hybrid,saddle_point)
  use dlf_global, only: glob, stdout
  use dlf_allocate
  use dlf_constants
  use dlf_vpt2_terms, only: vpt2_fundamentals
  use dlf_vpt2_utility, only: dlf_gl_bcast
  use omp_lib_kinds
  use omp_lib
  implicit none
  integer, intent(in) :: Neff,nT
  real(rk), dimension(Neff), intent(in) :: freq
  real(rk), dimension(Neff,Neff), intent(in) :: X
  real(rk), dimension(nT), intent(in) :: Temps
  logical, intent(in) :: hybrid
  logical, intent(in), optional :: saddle_point
  real(rk),dimension(nT) :: qvib_anharmonic_via_rho
  
  integer, parameter :: nrho=2000, nlistmax=nrho
  integer  :: i, j, nreal, nstates
  real(rk) :: Tmax, ener, tdiff
  real(rk), dimension(nrho) :: rho, nos, statelist
  real(rk), dimension(Neff) :: fundatmp
  integer(kind=8) :: cr,cm,tcount1,tcount2,delta_time
  
  if (glob%iam == 0) CALL system_clock(count_rate=cr, count_max=cm)
  
  if (present(saddle_point)) then
    if (saddle_point) then
      nreal=neff-1
    else
      nreal=neff
    endif
  else
    nreal=neff
  endif
  
  Nsav=nreal
  
  qnform=''
  write(qnform,'(A,I0,A)') '(',nreal,'(I0,1X))'
  
  if (allocated(freqsav)) call deallocate(freqsav)
  if (allocated(Xsav)) call deallocate(Xsav)
  call allocate(freqsav,nreal)
  call allocate(Xsav,nreal,nreal)
  
  freqsav(1:nreal)=freq(1:nreal)
  Xsav(1:nreal,1:nreal)=X(1:nreal,1:nreal)
  
  if (force_harmonic_approximation) then
    Xsav(1:nreal,1:nreal)=0._rk
    if (.not. force_harmonic_approximation_warning_dropped) then
      force_harmonic_approximation_warning_dropped=.true.
      write(stdout,'(A)') ''
      write(stdout,'(A)') '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'
      write(stdout,'(A)') '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'
      write(stdout,'(A)') ''
      write(stdout,'(A)') '             <<<<   WARNING!! >>>>           '
      write(stdout,'(A)') ''
      write(stdout,'(A)') ' Parameter "force_harmonic_approximation"'
      write(stdout,'(A)') ' is set to .true., meaning the anharmonic'
      write(stdout,'(A)') ' constants are ignored for the state counting'
      write(stdout,'(A)') ' routines.'
      write(stdout,'(A)') ''
      write(stdout,'(A)') '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'
      write(stdout,'(A)') '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'
      write(stdout,'(A)') ''
    endif
  endif
  
  if (hybrid) then
    if (allocated(vpt2fundasav)) call deallocate(vpt2fundasav)
    if (allocated(spt_mask_sav)) call deallocate(spt_mask_sav)
    call allocate(vpt2fundasav,nreal)
    call allocate(spt_mask_sav,nreal)
    spt_mask_sav(:)=.false.
    if (glob%iam == 0) call vpt2_fundamentals(Neff,freq,X,fundatmp,saddle_point)
    !call dlf_global_real_bcast(fundatmp,Neff,0)
    call dlf_gl_bcast(fundatmp,Neff,0)
    vpt2fundasav(1:nreal)=fundatmp(1:nreal)
  endif
  
  call dlf_constants_get("KBOLTZ_CM_INV",kb_cm_inv)
  
  Tmax=maxval(Temps,dim=1)
  Emaxsav=E_max_fit(nreal,Tmax)
  del_ener_sav=Emaxsav/real(nrho-1)

  !vmax_glob=ceiling(Emaxsav/minval(freqsav(1:nreal),dim=1))+10
  !allocate(histogram(0:vmax_glob))
  !do i=1,nreal
  !  call estimate_qn_histogram(nreal,i,freqsav,Emaxsav,vmax_glob,histogram)
  !  histfn=''
  !  write(histfn,'(A,I4.4,A)') 'histo_ho_estim_ivib=', i, '.dat'
  !  open(111,file=trim(adjustl(histfn)))
  !  call vector_output(histogram(0:vmax_glob),111,'F20.12','')
  !  close(111)
  !enddo
  !deallocate(histogram)
  
  if (glob%iam == 0) Eswitchsav=E_switch_estimate(nreal,nlistmax,freqsav(1:nreal))
  !call dlf_global_real_bcast_rank0(Eswitchsav,0)
  call dlf_gl_bcast(Eswitchsav,0)
  if (glob%iam == 0) call system_clock(count=tcount1)
  
!  call rhova_nonrec_parallel_mpi(glob%nprocs,8000,nrho,rho,statelist,nlistmax,nstates,hybrid,nos)
  call rhova_nonrec_parallel_mpi_dyn_sched(8000,100,nrho,rho,statelist,nlistmax,nstates,hybrid,nos)
  !call rhova_nonrec_parallel_benchmarks(nrho,rho,statelist,nlistmax,nstates,hybrid,nos)
  !if (glob%iam==0) then
  !  !call omp_set_schedule(omp_sched_guided,0)
  !  !call rhova_nonrec_parallel_openmp(1000,nrho,rho,statelist,nlistmax,nstates,.false.,hybrid,nos)
  !  call allocate(qn_min,nreal)
  !  call allocate(qn_max,nreal)
  !  qn_min(:)=0
  !  qn_max(:)=qnmax_param
  !  call rhova_nonrec(nrho,rho,statelist,nlistmax,nstates,qn_min,qn_max,hybrid,nos)
  !  !call rhova_nonrec(nrho,rho,statelist,nlistmax,nstates,qn_min,qn_max,hybrid,nos,histos)
  !  !allocate(histos(0:qnmax_param,nsav))
  !  !vmax_glob=ceiling(Emaxsav/minval(freqsav(1:nreal),dim=1))+10
  !  !do i=1,nsav
  !  !  histfn=''
  !  !  write(histfn,'(A,I4.4,A)') 'histo_ivib=', i, '.dat'
  !  !  open(111,file=trim(adjustl(histfn)))
  !  !  call vector_output(histos(0:vmax_glob,i),111,'F20.12','')
  !  !  close(111)
  !  !enddo
  !  !deallocate(histos)
  !  !call deallocate(qn_max)
  !  !call deallocate(qn_min)
  !    
  !  !!allocate(idumarr(0))
  !  !!rho(:)=0._rk
  !  !!nos(:)=0._rk
  !  !!statelist(:)=0._rk
  !  !!nstates=0
  !  !!Eswitchsav=E_switch_estimate(nreal,nlistmax,freqsav(1:nreal))
  !  !!call rhova_rec(nreal,nrho,rho,statelist,nlistmax,nstates,idumarr,hybrid,nos)
  !  !!deallocate(idumarr)
  !endif

  if (hybrid) then
    call deallocate(vpt2fundasav)
    call deallocate(spt_mask_sav)
  endif
  
  call deallocate(Xsav)
  call deallocate(freqsav)
  
  if (glob%iam == 0) then
    call system_clock(count=tcount2)
    delta_time=tcount2-tcount1
    tdiff=real(delta_time)/real(cr)
    write(stdout,*) 'Time for state count (seconds): ', tdiff
  endif
  
  do i=1,nT
    qvib_anharmonic_via_rho(i)=0._rk
    do j=1,nrho
      ener=(real(j-1)+0.5_rk)*del_ener_sav
      qvib_anharmonic_via_rho(i)=qvib_anharmonic_via_rho(i) & 
              & + rho(j) * del_ener_sav * exp(-ener/(kb_cm_inv*Temps(i)))
    enddo
    do j=1,nstates
      ener=statelist(j)
      qvib_anharmonic_via_rho(i)=qvib_anharmonic_via_rho(i) & 
              & + exp(-ener/(kb_cm_inv*Temps(i)))
    enddo
  enddo

  do j=1,nstates
    i=floor(statelist(j)/del_ener_sav)+1
    if (i < 1 .or. i > nrho) cycle
    rho(i)=rho(i)+1._rk/del_ener_sav
    nos(i:nrho)=nos(i:nrho)+1._rk
  enddo
  if (glob%iam == 0) then
    open(444,file='rho.out')
    open(555,file='nos.out')
      do j=1,nrho
        ener=(real(j-1)+0.5_rk)*del_ener_sav
        write(444,*) ener, rho(j)
        write(555,*) ener, nos(j)
      enddo
    close(444)
    close(555)
  endif
  
  return
end function qvib_anharmonic_via_rho

!***************************************************
!***************************************************

! Brute-force recursive counting routine, to give the density of states
! rho(E), and optionally the number of states (nos), a.k.a. sum of states, 
! which is the integrated density of states.

recursive subroutine rhova_rec(Nsub,nrho,rho,statelist,nstatesmax,nstates,qn_inact,hybrid,nos)
  use dlf_vpt2_terms, only: E_vpt2, E_vpt2_hybrid
  implicit none
  integer, intent(in) :: Nsub,nrho,nstatesmax
  integer, intent(inout) :: nstates
  real(rk), intent(inout), dimension(nrho)  :: rho
  real(rk), intent(inout), dimension(nstatesmax)  :: statelist
  integer, dimension(1:Nsav-Nsub), intent(in) :: qn_inact
  logical, intent(in) :: hybrid
  real(rk), intent(inout), dimension(nrho), optional  :: nos
  
  integer :: v,ibin
  real(rk) :: Eold,En
  integer, allocatable, dimension(:) :: izero
  
  if (hybrid) then
    spt_mask_sav(1:Nsub)=.false.
  endif
  
  if (Nsub == 1) then
    En=-1._rk
    do v=0,qnmax_param
      Eold=En
      if (hybrid) then
        En=E_vpt2_hybrid(Nsav,freqsav,vpt2fundasav,spt_mask_sav,[v,qn_inact],Xsav)
      else
        En=E_vpt2(Nsav,freqsav,[v,qn_inact],Xsav)
      endif
      if (En<Eold) then
        !write(stdout,*) '*** VPT2 breakdown. Energy decreases with increasing quantum number ***'
        !write(stdout,*) 'Eold, E: ', Eold, En
        if (hybrid) then
          spt_mask_sav(Nsub)=.true.
          En=E_vpt2_hybrid(Nsav,freqsav,vpt2fundasav,spt_mask_sav,[v,qn_inact],Xsav)
        else
          if(En<0._rk) exit
        endif
      endif
      if (En>=Emaxsav) then
        exit
      endif
      if (En>Eswitchsav .or. nstates==nstatesmax) then
        ibin=floor(En/del_ener_sav)+1
        rho(ibin)=rho(ibin)+1./del_ener_sav
        if (present(nos)) then
          nos(ibin:nrho)=nos(ibin:nrho)+1.
        endif
      else
        if (En >= 0._rk .and. En <= Emaxsav) then
          nstates=nstates+1
          statelist(nstates)=En
        endif
      endif
    enddo
  else
    En=-1._rk
    do v=0,qnmax_param
      Eold=En
      allocate(izero(Nsub-1))
      izero(:)=0
      if (hybrid) then
        En=E_vpt2_hybrid(Nsav,freqsav,vpt2fundasav,spt_mask_sav,[izero,v,qn_inact],Xsav)
      else
        En=E_vpt2(Nsav,freqsav,[izero,v,qn_inact],Xsav)
      endif
      deallocate(izero)
      if (En<Eold) then
        !write(stdout,*) '*** VPT2 breakdown. Energy decreases with increasing quantum number ***'
        !write(stdout,*) 'Eold, E: ', Eold, En
        if (hybrid) then
          spt_mask_sav(Nsub)=.true.
          En=E_vpt2_hybrid(Nsav,freqsav,vpt2fundasav,spt_mask_sav,[v,qn_inact],Xsav)
        else
          if(En<0._rk) exit
        endif
        !exit
      endif
      if (En>=Emaxsav) then
        exit
      endif
      if (present(nos)) then
        call rhova_rec(Nsub-1,nrho,rho,statelist,nstatesmax,nstates,[v,qn_inact],hybrid,nos)
      else
        call rhova_rec(Nsub-1,nrho,rho,statelist,nstatesmax,nstates,[v,qn_inact],hybrid)
      endif
    enddo
  endif
  return
end subroutine rhova_rec

!***************************************************
!***************************************************

! Non-recursive version of the brute-force density-of-states counting algorithm

subroutine rhova_nonrec(nrho,rho,statelist,nstatesmax,nstates,qnmin,qnmax,hybrid,nos,histos)
  use dlf_vpt2_terms, only: E_vpt2, E_vpt2_hybrid
  implicit none
  integer, intent(in) :: nrho,nstatesmax
  integer, intent(out) :: nstates
  real(rk), intent(out), dimension(nrho)  :: rho
  real(rk), intent(out), dimension(nstatesmax)  :: statelist
  integer, intent(in),dimension(Nsav) :: qnmin,qnmax
  logical, intent(in) :: hybrid
  real(rk), intent(out), dimension(nrho), optional  :: nos
  real(rk), intent(out), &
     & dimension(minval(qnmin,dim=1):maxval(qnmax,dim=1),nsav), optional :: histos
  
  logical, dimension(nsav)  :: spt_mask_local
  integer, dimension(nsav)  :: qnvec
  real(rk), dimension(nsav) :: Enold
  integer :: iqn,qncurr,ibin,i,statecounter
  real(rk) :: En
  integer(kind=8), allocatable, dimension(:,:) :: ihistos
  logical :: histo_mode
  
  rho(:)=0._rk
  statelist(:)=0._rk
  nstates=0
  spt_mask_local(:)=.false.
  
  if (present(nos)) then
    nos(:)=0._rk
  endif
  
  histo_mode=.false.
  if (present(histos)) then
    histo_mode=.true.
    allocate(ihistos(lbound(histos,dim=1):ubound(histos,dim=1), &
                   & lbound(histos,dim=2):ubound(histos,dim=2)))
    ihistos(:,:)=0
  endif
  
  qnvec(:) = qnmin(:)
  if (hybrid) then
    En=E_vpt2_hybrid(Nsav,freqsav,vpt2fundasav,spt_mask_local,qnvec,Xsav)
  else
    En=E_vpt2(Nsav,freqsav,qnvec,Xsav)
  endif
  Enold(:)=En
  if (En <= Emaxsav) then
    if (nstatesmax > 0) then
      nstates=1
      statelist(1)=En
    else
      ibin=floor(En/del_ener_sav)+1
      rho(ibin)=rho(ibin)+1._rk/del_ener_sav
      if (present(nos)) then
        nos(ibin:nrho)=nos(ibin:nrho)+1._rk
      endif
    endif
  else
    return
  endif
  
  statecounter=1
  
  outer: do while (.true.)
    if (all(qnvec(:)==qnmax(:))) then
      exit outer
    endif
    inner: do iqn=1,nsav
      !write(stdout,'(A,4I10)') 'iqn, qnvec(iqn), qnmin(iqn), qnmax(iqn): ', iqn, qnvec(iqn), qnmin(iqn), qnmax(iqn)
      if (qnvec(iqn) < qnmax(iqn)) then
        qnvec(iqn)=qnvec(iqn)+1
        qnvec(1:iqn-1) = qnmin(1:iqn-1)
        qncurr=iqn
        spt_mask_local(1:iqn-1)=.false.
        exit inner
      endif
    end do inner
    !write(stdout,*) 'qncurr: ', qncurr
    !write(stdout,qnform) (qnvec(i),i=1,nsav)
    !read(*,*)
    if (hybrid) then
      En=E_vpt2_hybrid(Nsav,freqsav,vpt2fundasav,spt_mask_local,qnvec,Xsav)
    else
      En=E_vpt2(Nsav,freqsav,qnvec,Xsav)
    endif
    if (En < Enold(qncurr)) then
      !write(stdout,*) 'qncurr: ', qncurr
      !write(stdout,qnform) (qnvec(i),i=1,nsav)
      !write(stdout,*) 'Enold, En: ', Enold(qncurr), En
      !read(*,*)
      if (hybrid) then
        spt_mask_local(qncurr)=.true.
        En=E_vpt2_hybrid(Nsav,freqsav,vpt2fundasav,spt_mask_local,qnvec,Xsav)
      else
        if(En<0._rk) then
          qnvec(1:qncurr)=qnmax(1:qncurr)
          cycle outer
        endif
      endif
    endif
    if(En<0._rk) then
      qnvec(1:qncurr)=qnmax(1:qncurr)
      cycle outer
    endif
    if (En > Emaxsav) then
      if (qncurr < nsav) then
        qnvec(1:qncurr)=qnmax(1:qncurr)
        cycle outer
      else 
        qnvec(:)=qnmax(:)
        exit outer
      endif
    endif
    if (En>Eswitchsav .or. nstates==nstatesmax) then
      !write(stdout,*) 'En: ', En
      !write(stdout,*) 'del_ener_sav: ', del_ener_sav
      ibin=floor(En/del_ener_sav)+1
      if (ibin>nrho) then
        write(*,*) 'ibin: ', ibin
        write(*,*) 'nrho: ', nrho
        write(*,*) 'del_ener_sav:', del_ener_sav
        write(*,*) 'En:', En
        write(*,*) 'Eswitchsav: ', Eswitchsav
        write(*,*) 'Emaxsav: ', Emaxsav
        read(*,*)
      endif
      rho(ibin)=rho(ibin)+1._rk/del_ener_sav
      if (present(nos)) then
        nos(ibin:nrho)=nos(ibin:nrho)+1._rk
      endif
    else
      if (En>=0._rk .and. En <= Emaxsav) then
        nstates=nstates+1
        statelist(nstates)=En
      endif
    endif
    if (histo_mode) then
      statecounter=statecounter+1
      do i=1,Nsav
        ihistos(qnvec(i),i)=ihistos(qnvec(i),i)+1
      enddo
    endif
    Enold(1:qncurr)=En
  end do outer
  
  if (histo_mode) then
    histos(:,:)=real(ihistos(:,:))/real(statecounter)
    deallocate(ihistos)
  endif
  
  return
end subroutine rhova_nonrec

!***************************************************
!***************************************************

! Non-recursive, OpenMP parallelized version of the brute-force density-of-states counting algorithm.
! The parallel scaling is rather poor.

subroutine rhova_nonrec_parallel_openmp(nbatches_max,nrho,rho,statelist,nstatesmax,nstates,sort_batches,hybrid,nos)
  use omp_lib_kinds
  use omp_lib
  use dlf_allocate, only: allocate, deallocate
  use dlf_sort_module, only: dlf_sort_shell
  implicit none
  integer, intent(in) :: nbatches_max
  integer, intent(in) :: nrho,nstatesmax
  integer, intent(out) :: nstates
  real(rk), intent(out), dimension(nrho)  :: rho
  real(rk), intent(out), dimension(nstatesmax)  :: statelist
  logical, intent(in) :: sort_batches,hybrid
  real(rk), intent(out), dimension(nrho), optional  :: nos
  
  integer :: nbatches_actual,ibatch,nstates_tot, ilo, iup, i, ibin
  integer, dimension(Nsav,2,nbatches_max) :: batches
  real(rk), dimension(nbatches_max) :: batch_sizes
  real(rk), dimension(nrho) :: rho_loc, nos_loc
  real(rk), dimension(nstatesmax,nbatches_max) :: statelist_loc
  integer, dimension(nbatches_max) :: nstates_loc
  real(rk), allocatable, dimension(:) :: statelist_combined
  
  call generate_state_count_batches(Nsav,freqsav,qnmax_param,Emaxsav,nbatches_max,nbatches_actual,batches,batch_sizes)
  if (sort_batches) call sort_batches_by_size(nbatches_actual,batches(:,:,1:nbatches_actual),batch_sizes(1:nbatches_actual))
  
  nstates_tot=0
  rho(:)=0._rk
  if (present(nos)) then
    nos(:)=0._rk
  endif
  
!  !$OMP PARALLEL private ( ibatch, rho_loc, nos_loc )
!  !$OMP DO schedule(runtime) private( ibatch, rho_loc, nos_loc ) reduction(+: rho, nos, nstates_tot)
!  do ibatch=1,nbatches_actual
!    call rhova_nonrec(nrho,rho_loc,statelist_loc(:,ibatch),nstatesmax, &
!        & nstates_loc(ibatch),batches(1:nsav,1,ibatch),batches(1:nsav,2,ibatch),hybrid,nos_loc)
!    nstates_tot=nstates_tot+nstates_loc(ibatch)
!    rho(:)=rho(:)+rho_loc(:)
!    if (present(nos)) then
!      nos(:)=nos(:)+nos_loc(:)
!    endif
!  enddo
!  !$OMP END DO
!  !$OMP END PARALLEL
  
  call allocate(statelist_combined,nstates_tot)
  iup=0
  do ibatch=1,nbatches_actual
    ilo=iup+1
    iup=ilo+nstates_loc(ibatch)-1
    statelist_combined(ilo:iup)=statelist_loc(1:nstates_loc(ibatch),ibatch)
  enddo
  nstates=min(nstatesmax,nstates_tot)
  call dlf_sort_shell(statelist_combined)
  statelist(1:nstates)=statelist_combined(1:nstates)
  if (nstates_tot > nstates) then
    do i=nstates+1,nstates_tot
      ibin=floor(statelist_combined(i)/del_ener_sav)+1
      rho(ibin)=rho(ibin)+1._rk/del_ener_sav
      if (present(nos)) then 
        nos(ibin:nrho)=nos(ibin:nrho)+1._rk
      endif
    enddo
  endif
  call deallocate(statelist_combined)
  
  return
end subroutine rhova_nonrec_parallel_openmp

!***************************************************
!***************************************************

! Non-recursive, MPI parallelized version of the brute-force density-of-states counting algorithm.
! The parallel scaling is ok.

subroutine rhova_nonrec_parallel_mpi(nproc,nbatches_max,nrho,rho,statelist,nstatesmax,nstates,hybrid,nos)
  use dlf_global, only: glob, stdout
  use dlf_allocate, only: allocate, deallocate
  use dlf_sort_module, only: dlf_sort_shell
  use dlf_vpt2_utility, only: error_print, dlf_gl_scatter, dlf_gl_bcast, dlf_gl_gather, dlf_gl_sum
  implicit none
  integer, intent(in) :: nproc,nbatches_max
  integer, intent(in) :: nrho,nstatesmax
  integer, intent(out) :: nstates
  real(rk), intent(out), dimension(nrho)  :: rho
  real(rk), intent(out), dimension(nstatesmax)  :: statelist
  logical, intent(in) :: hybrid
  real(rk), intent(out), dimension(nrho), optional  :: nos
  
  real(rk), dimension(nstatesmax)  :: statelist_proc
  integer :: nbatches_actual, ibatch, ilo, iup, i, ibin
  integer :: nstates_tot_proc, nstates_allproc, nstates_max_allproc
  integer, dimension(Nsav,2,nbatches_max) :: batches
  real(rk), dimension(nbatches_max) :: batch_sizes
  real(rk), dimension(nrho) :: rho_proc, nos_proc
  real(rk), dimension(nrho) :: rho_micro, nos_micro
  integer, allocatable, dimension(:,:,:,:) :: batches_sliced
  integer, allocatable, dimension(:,:,:) :: batches_proc
  real(rk), allocatable, dimension(:,:) :: statelist_micro
  real(rk), allocatable, dimension(:) :: statelist_combined_proc
  real(rk), allocatable, dimension(:) :: statelist_combined_allproc
  real(rk), allocatable, dimension(:,:) :: statelist_combined_allproc_matrix
  integer, allocatable, dimension(:) :: nstates_micro
  integer :: max_nbatch_per_proc, nbatches_proc, nstates_proc
  integer, dimension(nproc) :: nbatch_for_proc
  !integer, dimension(1,nproc) :: nstates_vec
  integer, dimension(nproc) :: nstates_vec
  integer(kind=8) :: cr,cm,tcount1,tcount2,delta_time
  real(rk) :: tdiff
  
  call system_clock(count_rate=cr, count_max=cm)
  
  ! This is the batch partitioning part, done only on rank=0 task
  if (glob%iam == 0) then
    if (nproc /=glob%nprocs) then
      call error_print("rhova_nonrec_parallel_mpi: invalid setting of dummy argument nproc")
    endif
    call generate_state_count_batches(Nsav,freqsav,qnmax_param,Emaxsav,nbatches_max,nbatches_actual,batches,batch_sizes)
    call sort_batches_by_size(nbatches_actual,batches(:,:,1:nbatches_actual),batch_sizes(1:nbatches_actual))
    
    max_nbatch_per_proc = int ( nbatches_actual / nproc ) + ceiling ( real(mod(nbatches_actual,nproc))/real(nproc) )
    allocate(batches_sliced(Nsav,2,max_nbatch_per_proc,nproc))
    batches_sliced(:,:,:,:)=qnmax_param
    do i=1,nproc
      nbatch_for_proc(i)= size(batches(:,:,i:nbatches_actual:nproc),dim=3)
      batches_sliced(:,:,1:nbatch_for_proc(i),i)=batches(:,:,i:nbatches_actual:nproc)
      !estimated_load_for_proc(i)=sum(batch_sizes(i:nbatches_actual:nproc))
    enddo
    
    write(stdout,*) 'nbatches_actual:       ', nbatches_actual
    write(stdout,*) 'nproc:                 ', nproc
    write(stdout,*) 'nbatches_actual/nproc: ', real(nbatches_actual)/real(nproc)
    write(stdout,*) 'max_nbatch_per_proc:   ', max_nbatch_per_proc
    write(stdout,*) 'Individual nbatches for proc i:'
    do i=1,nproc
      write(stdout,*) i,nbatch_for_proc(i)
    enddo
    
    nstates=0
    statelist=0._rk
    rho(:)=0._rk
    if (present(nos)) then
      nos(:)=0._rk
    endif
    
  endif
  
  ! Scatter the batches
  !call dlf_global_int_bcast_rank0(max_nbatch_per_proc,0)
  call dlf_gl_bcast(max_nbatch_per_proc,0)
  !call dlf_global_int_scatter_rank0( nbatch_for_proc, nbatches_proc, nproc, 0 )
  call dlf_gl_scatter( nbatch_for_proc, nbatches_proc, nproc, 0 )
  allocate(batches_proc(nsav,2,max_nbatch_per_proc))
  if (glob%iam /=0) then
    allocate(batches_sliced(0,0,0,0))
  endif
  !call dlf_global_int_scatter_rank3( batches_sliced, Nsav,2,max_nbatch_per_proc, batches_proc, nproc, 0 )
  call dlf_gl_scatter( batches_sliced, Nsav, 2, max_nbatch_per_proc, batches_proc, nproc, 0 )
  deallocate(batches_sliced)
  
  !write(stdout,*) "I am process no.     ", glob%iam
  !write(stdout,*) "max_nbatch_per_proc: ", max_nbatch_per_proc
  !write(stdout,*) "nbatches_proc:       ", nbatches_proc
  
  !stop 0

  ! Do the actual work on each task
  ! allocate and initialize local vectors
  
  call allocate(statelist_micro,nstatesmax,nbatches_proc)
  call allocate(nstates_micro,nbatches_proc)
  nstates_tot_proc=0
  rho_proc(:)=0._rk
  nos_proc(:)=0._rk
  statelist_micro(:,:)=0._rk
  nstates_micro(:)=0
  
  call system_clock(count=tcount1)
  do ibatch=1,nbatches_proc
    call rhova_nonrec(nrho,rho_micro,statelist_micro(:,ibatch),nstatesmax, &
        & nstates_micro(ibatch),batches_proc(1:nsav,1,ibatch), &
        & batches_proc(1:nsav,2,ibatch),hybrid,nos_micro)
    nstates_tot_proc=nstates_tot_proc+nstates_micro(ibatch)
    rho_proc(:)=rho_proc(:)+rho_micro(:)
    nos_proc(:)=nos_proc(:)+nos_micro(:)
  enddo

  deallocate(batches_proc)
  
  call allocate(statelist_combined_proc,nstates_tot_proc)
  iup=0
  do ibatch=1,nbatches_proc
    ilo=iup+1
    iup=ilo+nstates_micro(ibatch)-1
    statelist_combined_proc(ilo:iup)=statelist_micro(1:nstates_micro(ibatch),ibatch)
  enddo
  nstates_proc=min(nstatesmax,nstates_tot_proc)
  call dlf_sort_shell(statelist_combined_proc)
  statelist_proc(1:nstates_proc)=statelist_combined_proc(1:nstates_proc)
  if (nstates_tot_proc > nstates_proc) then
    do i=nstates_proc+1,nstates_tot_proc
      ibin=floor(statelist_combined_proc(i)/del_ener_sav)+1
      rho_proc(ibin)=rho_proc(ibin)+1._rk/del_ener_sav
      nos_proc(ibin:nrho)=nos_proc(ibin:nrho)+1._rk
    enddo
  endif

  call system_clock(count=tcount2)
  delta_time=tcount2-tcount1
  tdiff = real(delta_time)/real(cr)
  write(6,'(A,I4,F10.2)') 'iproc, time(s): ', glob%iam, tdiff
  write(6,'(A,I4,1X,I0)') 'iproc, nstates_proc', glob%iam, nstates_proc
  
  call deallocate(statelist_micro)
  call deallocate(nstates_micro)
  
  ! Do gathers and reductions respectively
  !call dlf_global_real_sum(rho_proc,nrho)
  call dlf_gl_sum(rho_proc,nrho)
  !call dlf_global_real_sum(nos_proc,nrho)
  call dlf_gl_sum(nos_proc,nrho)
  nstates_allproc=nstates_proc
  !call dlf_global_int_sum_rank0(nstates_allproc)
  call dlf_gl_sum(nstates_allproc)
  write(6,'(A,I4,1X,I0)') 'iproc, nstates_allproc', glob%iam, nstates_allproc
  !call dlf_global_int_gather_rank0(nstates_proc,nstates_vec,nproc,0)
  call dlf_gl_gather(nstates_proc,nstates_vec,nproc,0)
  if (glob%iam==0) then 
    nstates_max_allproc = maxval(nstates_vec,dim=1)
  endif
  !call dlf_global_int_bcast_rank0(nstates_max_allproc,0)
  call dlf_gl_bcast(nstates_max_allproc,0)
  write(6,'(A,I4,1X,I0)') 'iproc, nstates_max_allproc', glob%iam, nstates_max_allproc
  if (glob%iam==0) then 
    call allocate(statelist_combined_allproc,nstates_allproc)
  endif
  if (glob%iam==0) then 
    call allocate(statelist_combined_allproc_matrix,nstates_max_allproc,nproc)
  else
    allocate(statelist_combined_allproc_matrix(0,0))
  endif
  
  !call dlf_global_real_gather_rank1(statelist_proc(1:nstates_max_allproc), &
  !      & nstates_max_allproc,statelist_combined_allproc_matrix,nproc,0)
  call dlf_gl_gather(statelist_proc(1:nstates_max_allproc), &
        & nstates_max_allproc,statelist_combined_allproc_matrix,nproc,0)
  if (glob%iam/=0) then
    call deallocate(statelist_combined_allproc_matrix)
  endif
  
  ! Deallocate local arrays
  call deallocate(statelist_combined_proc)
  
  ! Collapse surplus explicitly listed states into density of states
  if (glob%iam==0) then
    rho(:)=rho_proc(:)
    if (present(nos)) then
      nos(:)=nos_proc(:)
    endif
    iup=0
    do i=1,nproc
      ilo=iup+1
      iup=ilo+nstates_vec(i)-1
      statelist_combined_allproc(ilo:iup)=statelist_combined_allproc_matrix(1:nstates_vec(i),i)
    enddo
    nstates=min(nstatesmax,nstates_allproc)
    call dlf_sort_shell(statelist_combined_allproc)
    statelist(1:nstates)=statelist_combined_allproc(1:nstates)
    if (nstates_allproc > nstatesmax) then
      do i=nstatesmax+1,nstates_allproc
        ibin=floor(statelist_combined_allproc(i)/del_ener_sav)+1
        rho(ibin)=rho(ibin)+1._rk/del_ener_sav
        if (present(nos)) then
          nos(ibin:nrho)=nos(ibin:nrho)+1._rk
        endif
      enddo
    endif
  endif
  
  ! Deallocate rank=0 arrays
  if (glob%iam == 0) then
    !deallocate(batches_sliced)
    call deallocate(statelist_combined_allproc)
    call deallocate(statelist_combined_allproc_matrix)
  endif
  
  ! Broadcast all intent(out) stuff
  !call dlf_global_int_bcast_rank0(nstates,0)
  call dlf_gl_bcast(nstates,0)
  !call dlf_global_real_bcast(rho,nrho,0)
  call dlf_gl_bcast(rho,nrho,0)
  !if (present(nos)) call dlf_global_real_bcast(nos,nrho,0)
  if (present(nos)) call dlf_gl_bcast(nos,nrho,0)
  !call dlf_global_real_bcast(statelist,nstatesmax,0)
  call dlf_gl_bcast(statelist,nstatesmax,0)
  
  return
end subroutine rhova_nonrec_parallel_mpi

!***************************************************
!***************************************************

! Non-recursive, MPI parallelized version of the brute-force density-of-states counting algorithm.
! The parallel scaling is ok. This routine has a different way of distributing processes along the 
! tasks (master-slave model)

subroutine rhova_nonrec_parallel_mpi_dyn_sched( &
                  & nbatches_max,nbatches_per_job,nrho,rho, & 
                  & statelist,nstatesmax,nstates,hybrid,nos)
  use dlf_global, only: glob, stdout
  use dlf_allocate, only: allocate, deallocate
  use dlf_sort_module, only: dlf_sort_shell
  use dlf_vpt2_utility, only: error_print, dlf_mpi_send, dlf_mpi_recv, &
                            & dlf_gl_bcast
  implicit none
  integer, intent(in) :: nbatches_max,nbatches_per_job
  integer, intent(in) :: nrho,nstatesmax
  integer, intent(out) :: nstates
  real(rk), intent(out), dimension(nrho)  :: rho
  real(rk), intent(out), dimension(nstatesmax)  :: statelist
  logical, intent(in) :: hybrid
  real(rk), intent(out), dimension(nrho), optional  :: nos
  
  real(rk), dimension(nstatesmax)  :: statelist_job
  integer :: nbatches_actual, ibatch, ilo, iup, i, ibin
  integer :: nstates_tot_job, nstates_alljobs, njobs
  integer, dimension(Nsav,2,nbatches_max) :: batches
  real(rk), dimension(nbatches_max) :: batch_sizes
  real(rk), dimension(nrho) :: rho_job, nos_job
  real(rk), dimension(nrho) :: rho_micro, nos_micro
  integer, allocatable, dimension(:,:,:,:),target :: batches_sliced
  integer, allocatable, dimension(:,:,:),target   :: batches_job
  real(rk), allocatable, dimension(:,:) :: statelist_micro
  real(rk), allocatable, dimension(:) :: statelist_combined_job
  real(rk), allocatable, dimension(:) :: statelist_combined_alljobs
  real(rk), allocatable, dimension(:,:),target :: statelist_combined_alljobs_matrix
  integer, allocatable, dimension(:) :: nstates_micro
  integer :: max_nbatch_per_job, nbatches_job, nstates_job
  integer, dimension(:),allocatable :: nbatch_for_job
  integer, dimension(:),allocatable :: nstates_vec
  logical, dimension(:), allocatable :: jobsent, jobdone, slaveterm
  integer :: i_req_typ, isource, itag
  integer :: curr_slave, kjob, nelem
  integer, dimension(:), pointer, contiguous :: batch_send, batch_recv
  integer, dimension(:,:,:), pointer, contiguous :: batch_send_rank3
  real(rk), dimension(:), pointer, contiguous :: list_recv
  integer, parameter :: my_tag_request =          1010
  integer, parameter :: my_tag_jobid   =          2020
  integer, parameter :: my_tag_jobsize =          3030
  integer, parameter :: my_tag_jobdata =          4040
  integer, parameter :: my_tag_results_rho =      5050
  integer, parameter :: my_tag_results_nos =      6060
  integer, parameter :: my_tag_results_nstates =  7070
  integer, parameter :: my_tag_results_statelist= 8080

  nullify(batch_send)
  nullify(batch_recv)
  nullify(list_recv)
  nullify(batch_send_rank3)

  if (glob%nprocs==1) then
    call rhova_nonrec_parallel_mpi(1,nbatches_max,nrho,rho,statelist,nstatesmax,nstates,hybrid,nos)
    return
  endif  

  ! This is the batch partitioning part, done only on rank=0 task
  if (glob%iam == 0) then
    call generate_state_count_batches(Nsav,freqsav,qnmax_param,Emaxsav, & 
                           & nbatches_max,nbatches_actual,batches,batch_sizes)
    njobs=int(nbatches_actual/nbatches_per_job)
    call allocate(nbatch_for_job,njobs)
    call allocate(nstates_vec,njobs)
    call allocate(jobsent,njobs)
    call allocate(jobdone,njobs)
    call allocate(slaveterm,glob%nprocs-1)
    call sort_batches_by_size(nbatches_actual,batches(:,:,1:nbatches_actual),batch_sizes(1:nbatches_actual))
    max_nbatch_per_job = int ( nbatches_actual / njobs ) + & 
                       &    ceiling ( real(mod(nbatches_actual,njobs))/real(njobs) )
    allocate(batches_sliced(Nsav,2,max_nbatch_per_job,njobs))
    batches_sliced(:,:,:,:)=qnmax_param
    do i=1,njobs
      nbatch_for_job(i)= size(batches(:,:,i:nbatches_actual:njobs),dim=3)
      batches_sliced(:,:,1:nbatch_for_job(i),i)=batches(:,:,i:nbatches_actual:njobs)
    enddo
    
    !write(stdout,*) 'nbatches_actual:       ', nbatches_actual
    !write(stdout,*) 'njobs:                 ', njobs
    !write(stdout,*) 'nbatches_actual/njobs: ', real(nbatches_actual)/real(njobs)
    !write(stdout,*) 'max_nbatch_per_job:    ', max_nbatch_per_job
    !write(stdout,*) 'Individual nbatches for job i:'
    !do i=1,njobs
    !  write(stdout,*) i,nbatch_for_job(i)
    !enddo
    
    nstates=0
    statelist=0._rk
    rho(:)=0._rk
    if (present(nos)) then
      nos(:)=0._rk
    endif
    call allocate(statelist_combined_alljobs_matrix,nstatesmax,njobs)
    statelist_combined_alljobs_matrix(:,:)=0._rk
  endif
  
  !call dlf_global_int_bcast_rank0(max_nbatch_per_job,0)
  call dlf_gl_bcast(max_nbatch_per_job,0)

  ! Master job distribution loop
  if (glob%iam==0) then
    jobdone(:)=.false.
    jobsent(:)=.false.
    slaveterm(:)=.false.
    do while (.true.)
      kjob=0
      ! exit loop when all slaves have already been given the signal to finish
      if (all(slaveterm)) exit
      ! Receive an integer token i_req_typ, in order to decide
      ! if this is a job request or a job result transfer inquiry
      curr_slave=-1
      itag=my_tag_request
      call dlf_mpi_recv(i_req_typ,curr_slave,itag)
      if     (i_req_typ==1) then
        ! job request
        if (all(jobdone(:).or.jobsent(:))) then
          ! Send job size of 0, signaling the slave to finish
          call dlf_mpi_send(0,curr_slave,my_tag_jobsize)
          slaveterm(curr_slave)=.true.
          cycle
        endif
        ! Choose the job to be sent to slave
        kjob=maxloc(merge(0,1,jobdone(:).or.jobsent(:)),dim=1)
        ! Send job size of kjob
        nbatches_job=nbatch_for_job(kjob)
        call dlf_mpi_send(nbatches_job,curr_slave,my_tag_jobsize)
        ! Send job id (=kjob)
        call dlf_mpi_send(kjob,curr_slave,my_tag_jobid)
        ! Send actual job (qn ranges from batches_sliced)
        ! First associate array pointer with job slice of batches_sliced
        nelem=Nsav*2*max_nbatch_per_job
        batch_send_rank3 => batches_sliced(:,:,:,kjob)
        batch_send(1:nelem) => batch_send_rank3
        ! Now do MPI send of batches
        call dlf_mpi_send(batch_send,nelem,curr_slave,my_tag_jobdata)
        nullify(batch_send)
        nullify(batch_send_rank3)
        ! Mark kjob as sent
        jobsent(kjob)=.true.
      elseif (i_req_typ==2) then
        ! job result transfer
        ! Receive job id
        isource=curr_slave
        itag=my_tag_jobid
        call dlf_mpi_recv(kjob,isource,itag)
        ! Receive rho
        isource=curr_slave
        itag=my_tag_results_rho
        call dlf_mpi_recv(rho_job,nrho,isource,itag)
        ! If applicable, receive nos
        if (present(nos)) then
          isource=curr_slave
          itag=my_tag_results_nos
          call dlf_mpi_recv(nos_job,nrho,isource,itag)
        endif
        ! Receive number of explicit states
        isource=curr_slave
        itag=my_tag_results_nstates
        call dlf_mpi_recv(nstates_job,isource,itag)
        nstates_vec(kjob)=nstates_job
        if (nstates_job>0) then
          list_recv(1:nstates_job) => statelist_combined_alljobs_matrix(1:nstates_job,kjob)
          ! Receive state list
          isource=curr_slave
          itag=my_tag_results_statelist
          call dlf_mpi_recv(list_recv,nstates_job,isource,itag)
          nullify(list_recv)
        endif
        jobdone(kjob)=.true.
        rho(:)=rho(:)+rho_job(:)
        if (present(nos)) then 
          nos(:)=nos(:)+nos_job(:)
        endif
      else                         
      ! other value -> problem (dummy for passing errors from slave to master)
        call error_print( &
            & 'rhova_nonrec_parallel_mpi_dyn_sched: a problem has '// &
            & 'occured during job execution by slave.')
      endif
    enddo
     nullify(batch_send)
     nullify(list_recv)
     nullify(batch_send_rank3)
    deallocate(batches_sliced)
  else
  ! Slave job request and execution loop
    do while (.true.)
      ! Tell master rank that the slave wants a new job
      i_req_typ=1
      call dlf_mpi_send(i_req_typ,0,my_tag_request)
      ! Receive job size
      isource=0
      itag=my_tag_jobsize
      call dlf_mpi_recv(nbatches_job,isource,itag)
      if (nbatches_job==0) then
        exit             ! Exit slave loop if master tells us everything's done
      endif
      isource=0
      itag=my_tag_jobid
      call dlf_mpi_recv(kjob,isource,itag)
      nelem=Nsav*2*max_nbatch_per_job
      allocate(batches_job(1:Nsav,1:2,1:max_nbatch_per_job))
      batch_recv(1:nelem) => batches_job
      ! Receive job
      isource=0
      itag=my_tag_jobdata
      call dlf_mpi_recv(batch_recv,nelem,isource,itag)
      nullify(batch_recv)
      ! Do the actual job
      call allocate(statelist_micro,nstatesmax,nbatches_job)
      call allocate(nstates_micro,nbatches_job)
      nstates_tot_job=0
      rho_job(:)=0._rk
      nos_job(:)=0._rk
      statelist_micro(:,:)=0._rk
      nstates_micro(:)=0
      do ibatch=1,nbatches_job
        call rhova_nonrec(nrho,rho_micro,statelist_micro(:,ibatch),nstatesmax, &
            & nstates_micro(ibatch),batches_job(1:nsav,1,ibatch), &
            & batches_job(1:nsav,2,ibatch),hybrid,nos_micro)
        nstates_tot_job=nstates_tot_job + nstates_micro(ibatch)
        rho_job(:)=rho_job(:)+rho_micro(:)
        nos_job(:)=nos_job(:)+nos_micro(:)
      enddo
      deallocate(batches_job)
      call allocate(statelist_combined_job,nstates_tot_job)
      iup=0
      do ibatch=1,nbatches_job
        ilo=iup+1
        iup=ilo+nstates_micro(ibatch)-1
        statelist_combined_job(ilo:iup)=statelist_micro(1:nstates_micro(ibatch),ibatch)
      enddo
      nstates_job=min(nstatesmax,nstates_tot_job)
      call dlf_sort_shell(statelist_combined_job)
      statelist_job(1:nstates_job)=statelist_combined_job(1:nstates_job)
      if (nstates_tot_job > nstates_job) then
        do i=nstates_job+1,nstates_tot_job
          ibin=floor(statelist_combined_job(i)/del_ener_sav)+1
          rho_job(ibin)=rho_job(ibin)+1._rk/del_ener_sav
          nos_job(ibin:nrho)=nos_job(ibin:nrho)+1._rk
        enddo
      endif
      call deallocate(statelist_combined_job)
      call deallocate(statelist_micro)
      call deallocate(nstates_micro)
      ! Report back on the master process that the results can be transferred back
      i_req_typ=2
      call dlf_mpi_send(i_req_typ,0,my_tag_request)
      ! Send job id
      call dlf_mpi_send(kjob,0,my_tag_jobid)
      ! Send back rho
      call dlf_mpi_send(rho_job,nrho,0,my_tag_results_rho)
      ! If applicable, send back nos
      if (present(nos)) then
        call dlf_mpi_send(nos_job,nrho,0,my_tag_results_nos)
      endif
      ! Send back number of explicit states
      call dlf_mpi_send(nstates_job,0,my_tag_results_nstates)
      ! Send back state list
      if (nstates_job>0) then
        call dlf_mpi_send(statelist_job(1:nstates_job),nstates_job,0,my_tag_results_statelist)
      endif
    enddo
    nullify(batch_recv)
  endif

  ! Collapse surplus explicitly listed states into density of states
  if (glob%iam==0) then
    nstates_alljobs=sum(nstates_vec(:))
    call allocate(statelist_combined_alljobs,nstates_alljobs)
    iup=0
    do i=1,njobs
      ilo=iup+1
      iup=ilo+nstates_vec(i)-1
      statelist_combined_alljobs(ilo:iup)=statelist_combined_alljobs_matrix(1:nstates_vec(i),i)
    enddo
    nstates=min(nstatesmax,nstates_alljobs)
    call dlf_sort_shell(statelist_combined_alljobs)
    statelist(1:nstates)=statelist_combined_alljobs(1:nstates)
    if (nstates_alljobs > nstatesmax) then
      do i=nstatesmax+1,nstates_alljobs
        ibin=floor(statelist_combined_alljobs(i)/del_ener_sav)+1
        rho(ibin)=rho(ibin)+1._rk/del_ener_sav
        if (present(nos)) then
          nos(ibin:nrho)=nos(ibin:nrho)+1._rk
        endif
      enddo
    endif
  
  ! Deallocate rank=0 arrays
    call deallocate(statelist_combined_alljobs)
    call deallocate(statelist_combined_alljobs_matrix)
    call deallocate(nbatch_for_job)
    call deallocate(nstates_vec)
    call deallocate(jobdone)
    call deallocate(jobsent)
    call deallocate(slaveterm)
  endif
  
  ! Broadcast all intent(out) stuff
  !call dlf_global_int_bcast_rank0(nstates,0)
  call dlf_gl_bcast(nstates,0)
  !call dlf_global_real_bcast(rho,nrho,0)
  call dlf_gl_bcast(rho,nrho,0)
  !if (present(nos)) call dlf_global_real_bcast(nos,nrho,0)
  if (present(nos)) call dlf_gl_bcast(nos,nrho,0)
  !call dlf_global_real_bcast(statelist,nstatesmax,0)
  call dlf_gl_bcast(statelist,nstatesmax,0)

  return
end subroutine rhova_nonrec_parallel_mpi_dyn_sched

!***************************************************
!***************************************************

! Testing routine for the OpenMP parallelized rho(E) counting 
! routine 

subroutine rhova_nonrec_parallel_openmp_benchmarks(nrho,rho,statelist,nstatesmax,nstates,hybrid,nos)
  use omp_lib_kinds
  use omp_lib
  use dlf_global, only: stdout
  implicit none
  
  integer, intent(in) :: nrho,nstatesmax
  integer, intent(out) :: nstates
  real(rk), intent(out), dimension(nrho)  :: rho
  real(rk), intent(out), dimension(nstatesmax)  :: statelist
  logical, intent(in) :: hybrid
  real(rk), intent(out), dimension(nrho), optional  :: nos
  
  integer, parameter :: nrepeat=5
  integer, parameter :: nbatches_lower=10
  integer, parameter :: nbatches_upper=100000
  integer, parameter :: nbatches_log10_step=1
  integer, parameter :: nproc_lower=1
  integer, parameter :: nproc_upper=4
  integer, parameter :: nproc_step=1
  
  integer, parameter :: nsched=4
  integer(kind=omp_sched_kind), dimension(nsched), parameter :: schedule = &
      &  [ omp_sched_static, omp_sched_dynamic, omp_sched_guided, omp_sched_auto ]
  character(len=7), dimension(nsched), parameter :: schedule_char = &
      &  [ 'static ', 'dynamic', 'guided ', 'auto   ' ]
  integer, parameter :: sched_modifier=0
  integer :: isched, irepeat, ibatch, isb
  integer :: nbatches, nbatch_values
  integer :: nproc
  logical :: sort_batches
  logical, dimension(2), parameter :: sb_vec = [.false., .true.]
  integer(kind=8) :: cr,cm,tcount1,tcount2,delta_time
  real(rk) :: tdiff,lg_nbmin,lg_nbmax
  integer, allocatable, dimension(:) :: nbatches_vec
  
  call system_clock(count_rate=cr, count_max=cm)
  
  lg_nbmin=log10(real(nbatches_lower))
  lg_nbmax=log10(real(nbatches_upper))
  nbatch_values=ceiling((lg_nbmax-lg_nbmin)/real(nbatches_log10_step))+1
  
  allocate(nbatches_vec(1:nbatch_values))
  do ibatch=1,nbatch_values
    nbatches_vec(ibatch)=10**nint(lg_nbmin+(ibatch-1)*nbatches_log10_step)
  enddo
  
  write(stdout,'(A6,A9,A15,A8,A20)') 'sort?' , 'sched.', 'nbatch', 'nproc', 't (s)'
  write(stdout,'(60A)') ('-', irepeat=1,60)
  do isb=1,2
    sort_batches=sb_vec(isb)
    do isched=1,nsched
      ! temporary catch added by JK
      call dlf_fail("have to terminate, programming error for serial execution...")
     ! call omp_set_schedule(schedule(isched),sched_modifier)
      do ibatch=1,nbatch_values
        nbatches=nbatches_vec(ibatch)
        do nproc=nproc_lower,nproc_upper,nproc_step
     !     call omp_set_num_threads(nproc)
          tdiff=0._rk
          do irepeat=1,nrepeat
            call system_clock(count=tcount1)
            call rhova_nonrec_parallel_openmp(nbatches,nrho,rho,statelist,nstatesmax,nstates,& 
                                              & sort_batches,hybrid,nos)
            call system_clock(count=tcount2)
            delta_time=tcount2-tcount1
            tdiff=tdiff+real(delta_time)/real(cr)
          enddo
          tdiff=tdiff/real(nrepeat)
          write(stdout,'(L6,A9,I15,I8,F20.12)') sort_batches, trim(adjustl(schedule_char(isched))), & 
                                              & nbatches, nproc, tdiff
        enddo
      enddo
    enddo
  enddo
  
  deallocate(nbatches_vec)
  
  return
end subroutine rhova_nonrec_parallel_openmp_benchmarks

!***************************************************
!***************************************************

subroutine sort_batches_by_size(nbatches,batches,batch_sizes)
  use dlf_sort_module, only: dlf_sort_shell_ind
  implicit none
  integer, intent(in) :: nbatches
  integer, dimension(Nsav,2,nbatches),intent(inout) :: batches
  real(rk), dimension(nbatches), intent(inout) :: batch_sizes
  
  integer, dimension(nbatches) :: sort_index
  integer, dimension(Nsav,2,nbatches) :: batches_tmp
  real(rk), dimension(nbatches) :: batch_sizes_tmp
  integer :: i,j
  
  call dlf_sort_shell_ind(batch_sizes,sort_index)
  sort_index(1:nbatches)=sort_index(nbatches:1:-1)
  
  do i=1,nbatches
    j=sort_index(i)
    batch_sizes_tmp(i)=batch_sizes(j)
    batches_tmp(:,:,i)=batches(:,:,j)
  enddo
  
  batches(:,:,:)=batches_tmp(:,:,:)
  batch_sizes(:)=batch_sizes_tmp(:)
  return
end subroutine sort_batches_by_size

!***************************************************
!***************************************************

! Estimate energy for the switch between an explicit state 
! list (low energies) and energy-binned grains (higher energies)

function E_switch_estimate(Nvib,nstates,freqs)
  use nr_gamma, only: gammln, sp
  use dlf_constants
  implicit none
  integer, intent(in)  :: Nvib, nstates
  real(rk), intent(in), dimension(Nvib) :: freqs
  real(rk) :: E_switch_estimate
  
  real(rk) :: sumlnfreq,esw,ezp,beta,z,x,f,der,delx, delxmax
  integer  :: i,iiter
  integer, parameter :: maxnewt=2000
  real(rk), parameter :: newtcon=0.001_rk
  
  ezp=sum(freqs(1:Nvib))/2._rk
  
  beta=real(Nvib-1)*sum(freqs(:)*freqs(:))/sum(freqs(:))**2
  
  sumlnfreq=0._rk
  
  do i=1,Nvib
    sumlnfreq=sumlnfreq + log(freqs(i))
  enddo
  
  esw=log(real(nstates)) + gammln(real(Nvib+1,kind=sp)) + sumlnfreq
  esw=exp(esw/real(Nvib))-ezp
  if (esw < 0._rk) esw=2*minval(freqs,dim=1)
  E_switch_estimate=esw
  
  x=esw/ezp
  z=x
  
  do iiter=1,maxnewt
    f=omega_whitten_rabinovitch(x,.true.,der)
    f=x-beta*f
    der=1._rk-beta*der
    !write(stdout,'(A,1X,I0,1X,2F20.12)') 'iiter, x, z-f: ', iiter, x, z-f
    !read(*,*)
    if (abs(z-f)<newtcon) then
      E_switch_estimate=x*ezp
      return
    endif
    delx=(z-f)/der
    delxmax=0.5_rk*abs(x)
    if (abs(delx)>delxmax) delx=sign(delxmax,delx)
    x=x+delx
  enddo
  
  return
end function E_switch_estimate

!***************************************************
!***************************************************

! Calculate omega parameter for the Whitten-Rabinovitch approximation 
! to calculate harmonic vibrational density of states rho(E)

function omega_whitten_rabinovitch(x,calc_deriv,deriv) result(w)
  implicit none
  real(rk), intent(in) :: x
  real(rk) :: w
  logical, intent(in), optional :: calc_deriv
  real(rk), intent(out), optional :: deriv
  
  real(rk) :: w1,w2,lam,dw1,dw2,dlam,tanhval
  
  w1 = -1.0506_rk * x**0.25_rk
  w1 = 10._rk**w1
  w2 = 5._rk * x + 2.73_rk * sqrt(x) + 3.51_rk
  w2 = 1._rk/w2
  tanhval=tanh(5._rk*log(x))
  lam=0.5_rk*(tanhval+1._rk)
  ! w1: high-E interpolation (good for 1<x<8)
  ! w2: low-E interpolation  (good for 0.1<x<1)
  w=lam*w1+(1._rk-lam)*w2
  
  if (present(calc_deriv)) then
    if (calc_deriv .and. present(deriv)) then
      dw1 = -w1*log(10._rk)*1.0506_rk/4._rk*x**(-0.75_rk)
      dw2 = -(5._rk + 1.365_rk / sqrt(x))*w2*w2
      dlam = 2.5_rk/x * (1._rk - tanhval*tanhval)
      deriv=dlam*(w1-w2) + lam*dw1 + (1._rk-lam)*dw2
    endif
  endif
  
  return
end function omega_whitten_rabinovitch

!***************************************************
!***************************************************

! Estimate quantum number histograms for all vibrations when counting all 
! conceivable vibrational quantum states from 0 to Emax. The estimation is done 
! within the harmonic approximation

subroutine estimate_qn_histogram(Nvib,ivib,freqs,Emax,vmax,histogram)
  implicit none
  integer, intent(in) :: Nvib,ivib,vmax
  real(rk), intent(in),dimension(Nvib) :: freqs
  real(rk), intent(in) :: Emax
  real(rk), dimension(0:vmax), intent(out) :: histogram
  
  integer, parameter :: N_nos=5000
  integer  :: v,iener,vmax_actual
  real(rk) :: dE_bs,ener
  real(rk), dimension(Nvib) :: freqs_temp
  real(rk), dimension(0:N_nos,1:Nvib) :: nos_all
  real(rk), dimension(0:N_nos) :: nos_init
  integer, allocatable, dimension(:) :: varr
  
  dE_bs=Emax/real(N_nos)
  nos_init(:)=dE_bs
  if (ivib == Nvib) then
    freqs_temp(:)=freqs(:)
  else
    freqs_temp(:)= [ freqs(1:ivib-1), freqs(ivib+1:Nvib), freqs(ivib) ]
  endif
  
  call beyer_swinehart_int_out(N_nos,dE_bs,Nvib,freqs_temp,nos_all,default_init=.false.,rho_in=nos_init)
  
  histogram(:)=0._rk
  vmax_actual=vmax
  do v=0,vmax
    ener=Emax-v*freqs_temp(Nvib)
    iener=floor(ener/dE_bs)
    if (iener < 0) then
      vmax_actual=v-1
      exit
    endif
    histogram(v)=nos_all(iener,Nvib-1)
  enddo
  
  allocate(varr(0:vmax_actual))
  do v=0,vmax_actual
    varr(v)=v
  enddo
  
  histogram(:)=histogram(:)/nos_all(N_nos,Nvib)
  histogram(:)=histogram(:)/sum(histogram(:))
  
  deallocate(varr)
  
  return
end subroutine estimate_qn_histogram

!***************************************************
!***************************************************

! Generate work packages for the brute-force state counts.
! This is for parallelization of the rho(E) count. Each work 
! package (or batch) is defined via a quantum number range for 
! each vibrational degree of freedom.

subroutine generate_state_count_batches(Nvib,freq,qnmax_hard,Emax, &
             & nbatches_max,nbatches_actual,batches,batch_sizes)
  use dlf_allocate, only: allocate, deallocate
  implicit none
  integer, intent(in)  :: Nvib,qnmax_hard,nbatches_max
  integer, intent(out) :: nbatches_actual
  real(rk), intent(in), dimension(Nvib) :: freq
  real(rk), intent(in) :: Emax
  integer, intent(out), dimension(Nvib,2,nbatches_max) :: batches
  real(rk), intent(out), dimension(nbatches_max) :: batch_sizes
  
  real(rk), parameter :: vmax_buffer=1.1_rk, maxmin_ratio_thresh=2.5_rk
  integer :: vmax_glob,ivib,ipart,np,ibatch,npmax
  real(rk), allocatable, dimension(:,:) :: histograms
  real(rk), allocatable, dimension(:)   :: fractions, fractions_save
  integer, allocatable, dimension(:)    :: part, part_save
  real(rk), allocatable, dimension(:,:) :: sizes_indiv
  integer, allocatable, dimension(:,:)  :: qnmin, qnmax
  integer, dimension(Nvib) :: npart,ipartvec
  real(rk) :: maxmin_ratio, maxmin_ratio_save
  
  vmax_glob=ceiling(Emax/minval(freq(1:Nvib),dim=1)*vmax_buffer)
  allocate(histograms(0:vmax_glob,Nvib))
  do ivib=1,Nvib
    call estimate_qn_histogram(Nvib,ivib,freq,Emax,vmax_glob,histograms(0:vmax_glob,ivib))
  enddo
  
  nbatches_actual=1
  
  call allocate(fractions,vmax_glob+1)
  call allocate(fractions_save,vmax_glob+1)
  call allocate(part,vmax_glob)
  call allocate(part_save,vmax_glob)
  call allocate(qnmin,vmax_glob+1,Nvib)
  call allocate(qnmax,vmax_glob+1,Nvib)
  call allocate(sizes_indiv,vmax_glob+1,Nvib)
  
  sizes_indiv(:,:)=0._rk
  sizes_indiv(1,:)=1._rk
  npart(:)=1
  qnmin(1,:)=0
  qnmax(1,:)=qnmax_hard
  do ivib=1,Nvib
    if (2*nbatches_actual > nbatches_max) then
      exit
    else
      npmax=min(floor(real(nbatches_max)/real(nbatches_actual)),vmax_glob+1)
    endif
    part(:)=0
    part_save(:)=0
    npart(ivib)=2
    fractions(:)=0._rk
    call optimal_partitions(vmax_glob,histograms(0:vmax_glob,ivib), &
                            & npart(ivib),part(1:npart(ivib)-1),maxmin_ratio, &
                            & fractions(1:npart(ivib)))
    do np=3,npmax
      part_save(:)=part(:)
      fractions_save(:)=fractions(:)
      maxmin_ratio_save=maxmin_ratio
      call optimal_partitions(vmax_glob,histograms(0:vmax_glob,ivib), &
                              & np,part(1:np-1),maxmin_ratio,fractions(1:np))
      if (maxmin_ratio > maxmin_ratio_thresh) then
        npart(ivib)=np-1
        part(:)=part_save(:)
        maxmin_ratio=maxmin_ratio_save
        fractions(:)=fractions_save(:)
        exit
      endif
    enddo
    qnmin(1,ivib)=0
    qnmax(npart(ivib),ivib)=qnmax_hard
    do ipart=2,npart(ivib)
      qnmin(ipart,ivib)=part(ipart-1)+1
    enddo
    do ipart=1,npart(ivib)-1
      qnmax(ipart,ivib)=part(ipart)
    enddo
    sizes_indiv(1:npart(ivib),ivib)=fractions(1:npart(ivib))
    nbatches_actual=nbatches_actual*npart(ivib)
  enddo
  
  ibatch=0
  ipartvec(:)=1
  ipartvec(1)=0
  batch_sizes=0._rk
  outer: do while (.true.)
    inner: do ivib=1,nsav
       if (ipartvec(ivib) < npart(ivib)) then
        ipartvec(ivib)=ipartvec(ivib)+1
        ipartvec(1:ivib-1) = 1
        !qncurr=iqn
        exit inner
      endif
    end do inner
    ibatch=ibatch+1
    batch_sizes(ibatch)=real(nbatches_actual)
    do ivib=1,nsav
      batches(ivib,1,ibatch)=qnmin(ipartvec(ivib),ivib)
      batches(ivib,2,ibatch)=qnmax(ipartvec(ivib),ivib)
      batch_sizes(ibatch)=batch_sizes(ibatch)*sizes_indiv(ipartvec(ivib),ivib)
    enddo
    if (all(ipartvec(:)==npart(:))) then
      exit outer
    endif
  end do outer
  
  deallocate(histograms)  
  call deallocate(sizes_indiv)
  call deallocate(qnmax)
  call deallocate(qnmin)
  call deallocate(part_save)
  call deallocate(part)
  call deallocate(fractions_save)
  call deallocate(fractions)
  
  return
end subroutine generate_state_count_batches

!***************************************************
!***************************************************

! Try to find optimal partitions for the work packages (batches), 
! so that the load balance is as close to uniform as possible.

subroutine optimal_partitions(vmax,histo,npart,part,maxmin_ratio,fractions)
  use dlf_linalg_interface_mod, only: dlf_dot_product
  use dlf_vpt2_utility, only: error_print  !, vector_output
  implicit none
  integer, intent(in) :: vmax,npart
  real(rk), intent(in), dimension(0:vmax) :: histo
  integer, intent(out), dimension(npart-1) :: part
  real(rk), intent(out) :: maxmin_ratio
  real(rk), dimension(npart), intent(out) :: fractions
  
  real(rk), dimension(npart) :: ideal_fractions  !, fractions_save
  real(rk), dimension(0:vmax) :: histo_norm
  real(rk) :: error_metric, error_metric_old, error_metric_trial
  integer, dimension(npart-1) :: part_save
  logical :: skipshift
  integer :: ipart,j,v
  
  histo_norm(:)=histo(:)/sum(histo(:))
  
  ideal_fractions(:) = 1._rk/real(npart)
  
  do v=1,npart-1
    part(v)=v-1
  enddo
  
  call get_fractions(vmax,npart,part,histo_norm,fractions)
  error_metric=dlf_dot_product(fractions-ideal_fractions,fractions-ideal_fractions)
  
  if (any(fractions(:)<=0._rk)) then
    maxmin_ratio=huge(maxmin_ratio)
    return
  endif
  
  error_metric_old=huge(error_metric_old)
  do while (error_metric < error_metric_old)
    if (any(part(1:npart-2)==part(2:npart-1))) then
      call error_print('optimal_partitions: part vector is corrupt')
    endif
    !write(stdout,*) 'err_metric, old_err_metric', error_metric, error_metric_old
    !call vector_output(fractions,stdout,'F20.12','fractions')
    error_metric_old=error_metric
    skipshift=.false.
    ! try a global shift of the compartments to the left
    if (part(1)/=0) then
      !write(stdout,*) 'Attempting a global left-shift'
      part_save(:)=part(:)
      !fractions_save(:)=fractions(:)
      part(:)=part(:)-1
      call get_fractions(vmax,npart,part,histo_norm,fractions)
      error_metric_trial=dlf_dot_product(fractions-ideal_fractions,fractions-ideal_fractions)
      if (error_metric_trial > error_metric .or. any(fractions(:)<=0._rk)) then
        part(:)=part_save(:)
        !fractions(:)=fractions_save(:)
        !write(stdout,*) 'Rejecting.'
      else
        error_metric=error_metric_trial
        skipshift=.true.
        !write(stdout,*) 'Accepting.'
      endif
    endif
    ! try a global shift of the compartments to the right
    if (part(npart-1)/=vmax-1 .and. .not.skipshift) then
      !write(stdout,*) 'Attempting a global right-shift'
      part_save(:)=part(:)
      !fractions_save(:)=fractions(:)
      part(:)=part(:)+1
      call get_fractions(vmax,npart,part,histo_norm,fractions)
      error_metric_trial=dlf_dot_product(fractions-ideal_fractions,fractions-ideal_fractions)
      if (error_metric_trial > error_metric .or. any(fractions(:)<=0._rk)) then
        part(:)=part_save(:)
        !fractions(:)=fractions_save(:)
        !write(stdout,*) 'Rejecting.'
      else
        error_metric=error_metric_trial
        !write(stdout,*) 'Accepting.'
      endif
    endif
    ! try to extend each partition individually to the left
    do ipart=2,npart
      ! Skip if all partitions to the left of the current one only cover one quantum number each
      if (part(ipart-1)==ipart-2) then
        cycle
      endif
      !write(stdout,*) 'Attempting to extend partition i to the left, i=', ipart
      part_save(:)=part(:)
      !fractions_save(:)=fractions(:)
      part(ipart-1)=part(ipart-1)-1
      do j=ipart-2,1,-1
        if (part(j)==part(j+1)) part(j)=part(j)-1
      enddo
      call get_fractions(vmax,npart,part,histo_norm,fractions)
      error_metric_trial=dlf_dot_product(fractions-ideal_fractions,fractions-ideal_fractions)
      if (error_metric_trial > error_metric .or. any(fractions(:)<=0._rk)) then
        part(:)=part_save(:)
        !fractions(:)=fractions_save(:)
        !write(stdout,*) 'Rejecting.'
      else
        error_metric=error_metric_trial
        !write(stdout,*) 'Accepting.'
      endif
    enddo
    ! try to extend each partition individually to the right
    do ipart=1,npart-1
      ! Skip if all partitions to the right of the current one only cover one quantum number each
      if (vmax-part(ipart)==npart-ipart) then
        cycle
      endif
      !write(stdout,*) 'Attempting to extend partition i to the right, i=', ipart
      part_save(:)=part(:)
      !fractions_save(:)=fractions(:)
      part(ipart)=part(ipart)+1
      do j=ipart+1,npart-1
        if (part(j)==part(j-1)) part(j)=part(j)+1
      enddo
      call get_fractions(vmax,npart,part,histo_norm,fractions)
      error_metric_trial=dlf_dot_product(fractions-ideal_fractions,fractions-ideal_fractions)
      if (error_metric_trial > error_metric .or. any(fractions(:)<=0._rk)) then
        part(:)=part_save(:)
        !fractions(:)=fractions_save(:)
        !write(stdout,*) 'Rejecting.'
      else
        error_metric=error_metric_trial
        !write(stdout,*) 'Accepting.'
      endif
    enddo
  enddo
  
  call get_fractions(vmax,npart,part,histo_norm,fractions)
  !write(stdout,*) 'err_metric, old_err_metric', error_metric, error_metric_old
  !call vector_output(fractions,stdout,'F20.12','fractions')
  maxmin_ratio=maxval(fractions,dim=1)/minval(fractions,dim=1)
  
  return
end subroutine optimal_partitions

!***************************************************
!***************************************************

! Get quantum number histogram fractions for the 
! work packages.

subroutine get_fractions(vmax,npart,part,histo,fractions)
  implicit none
  integer, intent(in) :: vmax, npart
  real(rk), intent(in), dimension(0:vmax) :: histo
  integer, intent(in), dimension(npart-1) :: part
  real(rk), intent(out), dimension(npart) :: fractions
  
  integer :: ipart,vlo,vup
  
  fractions(:)=0._rk
  do ipart=1,npart
    if (ipart==1) then
      vlo=0
    else
      vlo=part(ipart-1)+1
    endif
    if (ipart==npart) then
      vup=vmax
    else
      vup=part(ipart)
    endif
    fractions(ipart)=sum(histo(vlo:vup),dim=1)
  enddo
  
  return
end subroutine get_fractions

!***************************************************
!***************************************************

! Estimate the maximum energy that is needed for calculating
! vibrational partition functions up to the temperature Tmax, 
! with Nvib vibrational degrees of freedom. 
! Assumption: classical harmonic oscillator density of states, 
! then compare the Boltzmann fraction at Tmax below and above 
! the estimated Emax. If the ration above/below is smaller than 
! a threshold eps, Emax is considered sufficient.

function E_max(Nvib,Tmax)
  use nr_gamma, only: gammp, gammq, gammln
  use dlf_constants
  use dlf_global, only: stdout
  implicit none
  integer, intent(in)  :: Nvib
  real(rk), intent(in) :: Tmax
  real(rk) :: E_max
  
  real(kind=selected_real_kind(6)), parameter :: eps=1.e-4,newtcon=eps/20.
  integer, parameter :: maxnewt=5000
  integer :: neff,iiter
  real(kind=selected_real_kind(6)) :: lo, up, t, rneff,rnvib, delt, deltmax
  real(kind=selected_real_kind(6)) :: deriv, rat, gammneff
  
  integer, parameter :: nrho=500
  
  neff=Nvib+1
  rneff=real(neff,kind=kind(rneff))
  rnvib=real(nvib,kind=kind(rnvib))
  gammneff=gammln(rneff)
  
  call dlf_constants_get("KBOLTZ_CM_INV",kb_cm_inv)
  
  t=2*rnvib
  
  do iiter=1,maxnewt
    lo=gammp(rneff,t)
    up=gammq(rneff,t)
    if (lo==0.) then
      t=max(2*t,1.)
      cycle
    else
      rat=up/lo
    endif
    if (abs(rat-eps)<newtcon) then
      E_max=real(t,kind=kind(E_max))*kb_cm_inv*Tmax
      return
    endif
    deriv=rnvib*log(t) -t - gammneff
    deriv=exp(deriv)
    deriv=-deriv/(lo*lo)
    delt=(eps-rat)/deriv
    deltmax=abs(t)/10.
    if (abs(delt)>deltmax) then
      delt=sign(deltmax,delt)
    endif
    t=t+delt
  enddo
  
  write(stdout,*) 'No convergence in E_max (module dlf_vpt2_part_func)'
  call dlf_error()
end function E_max

!***************************************************
!***************************************************

! Like E_max above, but using an empirical fitting function.

function E_max_fit(Nvib,Tmax)
  use dlf_constants
  implicit none
  integer, intent(in)  :: Nvib
  real(rk), intent(in) :: Tmax
  real(rk) :: E_max_fit
  
  real(rk) :: prefactor,rnv
  real(rk), parameter :: a1=7.06678_rk
  real(rk), parameter :: a2=3.51795_rk
  
  call dlf_constants_get("KBOLTZ_CM_INV",kb_cm_inv)
  rnv=real(Nvib)
  prefactor = 1._rk + a1/rnv + a2/sqrt(rnv)
  prefactor = 1.1_rk*prefactor
  E_max_fit=kb_cm_inv*Tmax*rnv*prefactor
  return
end function E_max_fit

!**********************************************
!**********************************************

! Beyer-Swinehart algorithm for counting harmonic vibrational 
! density of states. (also known as "exact count", at least within
! the specified energy grain/bin size)

subroutine beyer_swinehart_vibdos(Nemax,dE,nvib,nyvib,rho_out,default_init,rho_in)
USE dlf_vpt2_utility, only: error_print
implicit none
integer, intent(in) :: Nemax,nvib
real(rk), intent(in) :: dE
real(rk), dimension(nvib), intent(in) :: nyvib
logical, intent(in) :: default_init
real(rk), dimension(0:Nemax), intent(out) :: rho_out
real(rk), dimension(0:Nemax), intent(in), optional :: rho_in

real(rk), dimension(0:Nemax) :: rho
integer, dimension(nvib) :: iny
integer :: i,j

if (.not. default_init .and. .not. present(rho_in)) then
  call error_print ('beyer-swinehart: must provide rho_in when default_init=.false.')
endif

if (default_init) then
  rho=0._rk
  rho(0)=1._rk
else
  rho=rho_in
endif

do i=1,nvib
  iny(i) = nint(nyvib(i)/dE)
enddo

do i=1,nvib
  do j=iny(i),Nemax
    rho(j)=rho(j)+rho(j-iny(i))
  enddo
enddo

rho_out=rho/dE

return
end subroutine beyer_swinehart_vibdos

!**********************************************
!**********************************************

! Beyer-Swinehart count (see above), but the intermediate results are 
! output as well. (Step-wise convolution of the DOS of the subsequent
! degrees of freedom can be followed)

subroutine beyer_swinehart_int_out(Nemax,dE,nvib,nyvib,rho_out,default_init,rho_in)
use dlf_vpt2_utility, only: error_print
implicit none
integer, intent(in) :: Nemax,nvib
real(rk), intent(in) :: dE
real(rk), dimension(nvib), intent(in) :: nyvib
logical, intent(in) :: default_init
real(rk), dimension(0:Nemax,1:nvib), intent(out) :: rho_out
real(rk), dimension(0:Nemax), intent(in), optional :: rho_in

real(rk), dimension(0:Nemax) :: rho
integer, dimension(nvib) :: iny
integer :: i,j

if (.not. default_init .and. .not. present(rho_in)) then
  call error_print('Error in beyer_swinehart_int_out: must provide rho_in when default_init=.false.')
endif

if (default_init) then
  rho=0._rk
  rho(0)=1._rk
else
  rho=rho_in
endif

do i=1,nvib
  iny(i) = nint(nyvib(i)/dE)
enddo

do i=1,nvib
  do j=iny(i),Nemax
    rho(j)=rho(j)+rho(j-iny(i))
  enddo
  rho_out(0:Nemax,i)=rho(0:Nemax)/dE
enddo

return
end subroutine beyer_swinehart_int_out

!**********************************************
!**********************************************


end module dlf_vpt2_part_func

